// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Credit to the ryu algorithm: https://dl.acm.org/doi/pdf/10.1145/3192366.3192369

component Floats {
	private def FLOAT_EXP_WIDTH: byte = 8;
	private def FLOAT_SIGN_WIDTH: byte = 1;
	private def FLOAT_MANTISSA_BITS: byte = 23;
	private def FLOAT_BIAS: byte = 127;

	private def DEBUG: bool = true;

    def renderFloat(val: float, a: Array<byte>, pos: int) -> int {
		var length: int = 0;
        if (u32.view(val) >> byte.!(FLOAT_MANTISSA_BITS + FLOAT_EXP_WIDTH) == 1u) {
			a[pos++] = '-';
			return 1 + renderPosFloat(val, a, pos);
		}
		return renderPosFloat(val, a, pos);
    }
	

	def renderPosFloat(val: float, a: Array<byte>, pos: int) -> int {
		var bits = u32.view(val);
		var exponent: u32 = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXP_WIDTH) - 1);
		var mantissa: u32 = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);

		if (DEBUG)
			System.puts(Strings.format2("Exponent: %d | Mantissa: %d \n", exponent, mantissa));

		if (exponent == u32.view(0b11111111) || (exponent == 0 && mantissa == 0)) {
			return renderFloatSpecial(exponent, mantissa, a, pos);
		}

		return renderPosFloatNaive(exponent, mantissa, a, pos);
	}


	def renderFloatSpecial(exponent: u32, mantissa: u32, a: Array<byte>, pos: int) -> int {
		if (mantissa != 0) {
			a[pos++] = 'N';
			a[pos++] = 'a';
			a[pos] = 'N';
			return 3;
		}
		if (exponent != 0) {
			a[pos++] = 'I';
			a[pos++] = 'n';
			a[pos++] = 'f';
			a[pos++] = 'i';
			a[pos++] = 'n';
			a[pos++] = 'i';
			a[pos++] = 't';
			a[pos] = 'y';
			return 8;
		}
		a[pos] = '0';
		return 1;
	}

	def renderPosFloatNaive(exponent: u32, mantissa: u32, arr: Array<byte>, pos: int) -> int {
		// Step 1: Decode
		var e_f: int;
		var m_f: u32;

		if (exponent == 0) {
			m_f = mantissa;
			e_f = int.!(1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS);
		}
		else {
			m_f = (1u << FLOAT_MANTISSA_BITS) + mantissa;
			e_f = int.!(exponent) - FLOAT_BIAS - FLOAT_MANTISSA_BITS;
		}

		if (DEBUG)
			System.puts(Strings.format2("m_f & e_f: %d * 2^%d \n", m_f, e_f));

		var e_2: int = e_f - 2;

		// Step 2: Determine interval of information preserving outputs
		var v: u32 = 4u * m_f;
		var w: u32 = 4u * m_f + 2u;
		var u: u32 = 4u * m_f;
		if (mantissa == 0 && exponent > 1)
			u -= 1u;
		else
			u -= 2u;
		
		// Step 3: Convert (u,v,w) * 2^(e_2) to a decimal power base.

		var e_10: int;
        var a: (u64, u64);
        var b: (u64, u64);
        var c: (u64, u64);

        if (e_2 >= 0) {
            e_10 = 0;
            var exp: (u64, u64) = u128Shift((0u, 1u), e_2);
            a = u128Mult((0, u64.view(u)), exp);
            b = u128Mult((0, u64.view(v)), exp);
            c = u128Mult((0, u64.view(w)), exp);
        }
        else {
            e_10 = e_2;
            var exp: (u64, u64) = pow5(u32.!(-e_2));
            a = u128Mult((0, u64.view(u)), exp);
            b = u128Mult((0, u64.view(v)), exp);
            c = u128Mult((0, u64.view(w)), exp);
        }

        System.puts(Strings.format2("v: %d, e_2: %d \n", v, e_2));
        // System.puts(Strings.format2("b: %d, e_10: %d \n", b, e_10));

		var acceptLarger: bool = mantissa % 2 == 0;
		var acceptSmaller: bool = acceptLarger;

		var t = computeShortest(a, b, c, acceptSmaller, acceptLarger);
		System.puts(Strings.format2("d_0: %d, e_0: %d \n", t.0, t.1 + e_10));

		return renderFloatingDecimal(t.0, t.1 + e_10, arr, pos);
	}

	// O(n) naive operation
	def pow5(n: u32) -> (u64, u64) {
		var result: (u64, u64) = (0u, 1u);
		for (i = 0; i < n; i++)
			result = u128Mult(result, (0u, 5u));
		return result;
	}

	def computeShortest(a: (u64, u64), b: (u64, u64), c: (u64, u64), acceptSmaller: bool, acceptLarger: bool) -> (u64, int) {
		var i: int = 0;
		if (!acceptLarger)
			c = u128Subtract(c, (0u, 1u));
		var all_a_zero: bool = true;
		var all_b_zero: bool = true;
		var digit: u64 = 0;

		
		while (u128Compare(u128Div10(a), u128Div10(c)) < 0) {
			all_a_zero = all_a_zero && (u128Mod10(a) == 0);
			a = u128Div10(a);
			c = u128Div10(c);

			digit = u128Mod10(b);
			all_b_zero = all_b_zero && digit == 0;
			b = u128Div10(b);

			i += 1;
		}
		if (acceptSmaller && all_a_zero) {
			while (u128Mod10(a) == 0) {
				a = u128Div10(a);
				c = u128Div10(c);
				i += 1;

				digit = u128Mod10(b);
				all_b_zero = all_b_zero && digit == 0;
				b = u128Div10(b);
			}
		}

		var break_tie_down = (b.1 % 2 == 0);
		var is_tie: bool = (digit == 5) && all_b_zero;
		var want_round_down: bool = (digit < 5) || (is_tie && break_tie_down);
		var round_down: bool = (want_round_down && (u128Compare(a, b) != 0 || all_a_zero)) || (u128Compare(u128Add(b, (0u, 1u)), c) > 0);

		if (round_down)
			return (b.1, i);
		return (b.1 + 1, i);
	}

	def renderFloatingDecimal(d: u64, e: int, a: Array<byte>, pos: int) -> int {
		var startingPos: int = pos;
		var digitWidth: int = 1;
		var t = getLastPosDecimalDigit(d);
		while (t.0 != 0) {
			t = getLastPosDecimalDigit(t.0);
			digitWidth += 1;
		}
		var digitsRight: int = Ints.min(Ints.max(0, -e), digitWidth);
		if (DEBUG)
		{
			System.puts(Strings.format1("Digit width is: %d \n", digitWidth));
			System.puts(Strings.format1("Sig Digits right of decimal point: %d\n", digitsRight));
		}

		var length: int = 0;
		var isZeroPointX: bool = false;
		if (e >= 0) {
			length = digitWidth + e;
		} else {
			length = digitWidth + 1; // add the decimal point
			if (digitWidth + e <= 0) {
				isZeroPointX = true;
				length += 1 + -(digitWidth + e);
			}
		}

		if (DEBUG)
			System.puts(Strings.format1("Unsigned float length is: %d \n", length));

		pos += length - 1; // start from to right, move to left

		// render trailing zeros before decimal point
		for (i = 0; i < e; i++)
			a[pos--] = '0';
		
		// render digits right of decimal point
		var n: u64 = d;
		for (i = 0; i < digitsRight; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		// render leading zeros right of decimal point
		for (i = digitWidth + e; i < 0; i++)
			a[pos--] = '0';
		
		// render "0."" or "."
		if (isZeroPointX) {
			a[pos--] = '.';
			a[pos--] = '0';
		} else if (e < 0) {
			a[pos--] = '.';
		}

		// render digits left of decimal point
		for (i = 0; i < digitWidth - digitsRight; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		if (DEBUG)
		{
			System.puts("Rendered: ");
			for (i = startingPos; i < startingPos + length; i++)
			{
				System.puts(Strings.format1("%c", a[i]));
			}
			System.puts("\n");
		}

		return length;
	}

	def getLastPosDecimalDigit(d: u64) -> (u64, int) {
		return (d / 10, int.view(d) % 10);
	}

	def u128Compare(a : (u64, u64), b: (u64, u64)) -> i64 {
		var a_hi: u64 = a.0;
		var a_lo: u64 = a.1;
		var b_hi: u64 = b.0;
		var b_lo: u64 = b.1;

		if (a_hi == b_hi)
			return i64.view(a_lo) - i64.view(b_lo);
		return i64.view(a_hi) - i64.view(b_hi);
	}

	def u128Add(a: (u64, u64), b: (u64, u64)) -> (u64, u64) {
		var a_hi = a.0;
		var a_lo = a.1;
		var b_hi = b.0;
		var b_lo = b.1;
		var res_lo = a_lo + b_lo;
		var carry: u64 = 0;
		if (res_lo < a_lo) carry = 1;
		var res_hi = a_hi + b_hi + carry;
		return (res_hi, res_lo);
	}

	def u128Subtract(a: (u64, u64), b: (u64, u64)) -> (u64, u64) {
		var a_hi = a.0;
		var a_lo = a.1;
		var b_hi = b.0;
		var b_lo = b.1;
		var res_lo = a_lo - b_lo;
		var borrow: u64 = 0;
		if (a_lo < b_lo) borrow = 1;
		var res_hi = a_hi - b_hi - borrow;
		return (res_hi, res_lo);
	}

	def u128Shift(val: (u64, u64), shift: int) -> (u64, u64) {
		var hi = val.0;
		var lo = val.1;
		if (shift == 0) {
			return val;
		}
		if (shift > 0) { // Left shift
			var s = u64.view(shift);
			if (s >= 128) {
				return (0, 0);
			}
			if (s >= 64) {
				return (lo << byte.!(s - 64), 0);
			}
			var res_hi = (hi << byte.!(s)) | (lo >> byte.!(64u - s));
			var res_lo = lo << byte.!(s);
			return (res_hi, res_lo);
		} else { // Right shift
			var s = u64.view(-shift);
			if (s >= 128) {
				return (0, 0);
			}
			if (s >= 64) {
				return (0, hi >> byte.!(s - 64u));
			}
			var res_lo = (lo >> byte.!(s)) | (hi << byte.!(64u - s));
			var res_hi = hi >> byte.!(s);
			return (res_hi, res_lo);
		}
	}

	def u128Mult(a : (u64, u64), b: (u64, u64)) -> (u64, u64) {
		var a_hi: u64 = a.0;
		var a_lo: u64 = a.1;
		var b_hi: u64 = b.0;
		var b_lo: u64 = b.1;

		var t = mult64to128(a_lo, b_lo);
		var p_lo_hi: u64 = t.0;
		var p_lo_lo: u64 = t.1;

		var mid1 = a_hi * b_lo;
		var mid2 = a_lo * b_hi;

		// Combine the parts
		var res_hi = p_lo_hi + mid1 + mid2;

		return (res_hi, p_lo_lo);
	}

	def u128Mod10(a: (u64, u64)) -> u64 {
		// N mod 10 = (hi * 2^64 + lo) mod 10
		// = ( (hi mod 10) * (2^64 mod 10) + (lo mod 10) ) mod 10
		// = ( (hi % 10) * 6 + (lo % 10) ) % 10
		var hi_rem = a.0 % 10;
		var lo_rem = a.1 % 10;
		return (hi_rem * 6 + lo_rem) % 10;
	}

	def u128Div10(a: (u64, u64)) -> (u64, u64) {
		// Divides a u128 by 10 using long division on 32-bit chunks.
		var hi = a.0;
		var lo = a.1;
		var d: u64 = 10;

		var h_h = hi >> 32;
		var h_l = hi & 0xFFFFFFFFu;
		var l_h = lo >> 32;
		var l_l = lo & 0xFFFFFFFFu;

		var rem: u64 = 0;

		var val = h_h;
		var q1 = val / d;
		rem = val % d;

		val = (rem << 32) | h_l;
		var q2 = val / d;
		rem = val % d;

		val = (rem << 32) | l_h;
		var q3 = val / d;
		rem = val % d;

		val = (rem << 32) | l_l;
		var q4 = val / d;

		var q_hi = (q1 << 32) | q2;
		var q_lo = (q3 << 32) | q4;

		return (q_hi, q_lo);
	}

	private def mult64to128(a: u64, b: u64) -> (u64, u64) {
		// Multiplies two u64 numbers to produce a 128-bit result (hi, lo)
		// Based on Hacker's Delight
		var a_lo = a & 0xFFFFFFFFu;
		var a_hi = a >> 32;
		var b_lo = b & 0xFFFFFFFFu;
		var b_hi = b >> 32;

		var p0 = a_lo * b_lo;
		var p1 = a_lo * b_hi;
		var p2 = a_hi * b_lo;
		var p3 = a_hi * b_hi;

		var p0_hi = p0 >> 32;

		var mid_sum = p0_hi + (p1 & 0xFFFFFFFFu) + (p2 & 0xFFFFFFFFu);

		var res_lo = (p0 & 0xFFFFFFFFu) | ((mid_sum & 0xFFFFFFFFu) << 32);
		var res_hi = p3 + (p1 >> 32) + (p2 >> 32) + (mid_sum >> 32);

		return (res_hi, res_lo);
	}
}

