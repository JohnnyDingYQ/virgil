// Copyright 2024 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// ====================== Start of Ryu license ========================
// Copyright 2018 Ulf Adams
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ======================== End of Ryu license =========================

// ===========================  Credits  ===============================
// This file is an combination of
// 1. Implementations in Virgil with respect to the ryu paper
//    @ https://dl.acm.org/doi/pdf/10.1145/3192366.3192369
// 2. Heavily modified arithmetics and numerical methods derived
//	  from of the original work by Ulf Adams
//    @ https://github.com/ulfjack/ryu.
// =====================================================================

component Floats {
	private def FLOAT_EXP_WIDTH: byte = 8;
	private def FLOAT_SIGN_WIDTH: byte = 1;
	private def FLOAT_MANTISSA_BITS: byte = 23;
	private def FLOAT_BIAS: byte = 127;
	private def FLOAT_POW5_BITCOUNT: byte = 61;

	private def DEBUG: bool = true;

	def renderFloat(val: float, a: Array<byte>, pos: int) -> int {
		var length: int = 0;
		if (u32.view(val) >> byte.!(FLOAT_MANTISSA_BITS + FLOAT_EXP_WIDTH) == 1u) {
			a[pos++] = '-';
			return 1 + renderPosFloat(val, a, pos);
		}
		return renderPosFloat(val, a, pos);
	}
	

	def renderPosFloat(val: float, a: Array<byte>, pos: int) -> int {
		var bits = u32.view(val);
		var exponent: u32 = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXP_WIDTH) - 1);
		var mantissa: u32 = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);

		if (DEBUG)
			System.puts(Strings.format2("Exponent: %d | Mantissa: %d \n", exponent, mantissa));

		if (exponent == u32.view(0b11111111) || (exponent == 0 && mantissa == 0)) {
			return renderFloatSpecial(exponent, mantissa, a, pos);
		}

		return renderPosFloatNaive(exponent, mantissa, a, pos);
	}


	def renderFloatSpecial(exponent: u32, mantissa: u32, a: Array<byte>, pos: int) -> int {
		if (mantissa != 0) {
			a[pos++] = 'N';
			a[pos++] = 'a';
			a[pos] = 'N';
			return 3;
		}
		if (exponent != 0) {
			a[pos++] = 'I';
			a[pos++] = 'n';
			a[pos++] = 'f';
			a[pos++] = 'i';
			a[pos++] = 'n';
			a[pos++] = 'i';
			a[pos++] = 't';
			a[pos] = 'y';
			return 8;
		}
		a[pos] = '0';
		return 1;
	}

	def renderPosFloatNaive(exponent: u32, mantissa: u32, arr: Array<byte>, pos: int) -> int {
		// Step 1: Decode
		var e_f: int;
		var m_f: u32;

		if (exponent == 0) {
			m_f = mantissa;
			e_f = int.!(1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS);
		}
		else {
			m_f = (1u << FLOAT_MANTISSA_BITS) + mantissa;
			e_f = int.!(exponent) - FLOAT_BIAS - FLOAT_MANTISSA_BITS;
		}

		if (DEBUG)
			System.puts(Strings.format2("m_f & e_f: %d * 2^%d \n", m_f, e_f));

		var e_2: int = e_f - 2;

		// Step 2: Determine interval of information preserving outputs
		var v: u32 = 4u * m_f;
		var w: u32 = 4u * m_f + 2u;
		var u: u32 = 4u * m_f;
		if (mantissa == 0 && exponent > 1)
			u -= 1u;
		else
			u -= 2u;

		if (DEBUG)
			System.puts(Strings.format2("v: %d, e_2: %d \n", v, e_2));
		
		// Step 3: Convert (u,v,w) * 2^(e_2) to a decimal power base.
		var e_10: int;
		var a: (u32, u32, u32, u32);
		var b: (u32, u32, u32, u32);
		var c: (u32, u32, u32, u32);
		var digit: u32 = 0; // last removed digit
		var all_a_zero: bool = false;
		var all_b_zero: bool = false;
		var acceptBounds: bool = mantissa % 2 == 0;

		if (e_2 >= 0) {
			// u128 will not be overflowed here as shown both empirically and theoretically.
			// We don't have to implement clever arithemtics here
			// As trade-off, we have to keep using u128 operations until the end of compute_shortest
			e_10 = 0;
			var exp: (u32, u32, u32, u32) = u128Shift((0u, 0u, 0u, 1u), e_2);
			a = u128Mult((0u, 0u, 0u, u), exp);
			b = u128Mult((0u, 0u, 0u, v), exp);
			c = u128Mult((0u, 0u, 0u, w), exp);
			all_a_zero = true;
			all_b_zero = true;
		}
		else {
			// u128 can be overflowed here. As a result, clever tricks are needed
			// See https://github.com/ulfjack/ryu/blob/master/ryu/f2s.c for more details
			// The resulting a, b, and c are guaranteed to be within u32 range
			// However, we still store them in u128 to take care of case e >= 0
			var q: int = log10Pow5(u32.!(-e_2));
			var i: int = -e_2 - q;
			var factor: (u32, u32, u32, u32) = pow5(u32.!(i));
			e_10 = e_2 + q;
			a = multAndShift(u, factor, q);
			b = multAndShift(v, factor, q);
			c = multAndShift(w, factor, q);

			digit = u128Mod10(multAndShift(v, pow5(u32.!(i + 1)), q - 1));
			if (q <= 1) {
				all_b_zero = true;
				if (acceptBounds) {
					all_a_zero = mantissa != 0 || exponent <= 1;
				}
			} else {
				all_b_zero = multipleOfPowerOf2(v, u32.!(q - 1));
			}

			if (DEBUG) {
				System.puts(Strings.format1("digit: %d \n", digit));
				System.puts(Strings.format1("q: %d \n", q));
			}
		}

		if (DEBUG) {
			System.puts(Strings.format2("a: %d %d", a.0, a.1));
			System.puts(Strings.format2(" %d %d\n", a.2, a.3));

			System.puts(Strings.format2("b: %d %d", b.0, b.1));
			System.puts(Strings.format2(" %d %d\n", b.2, b.3));

			System.puts(Strings.format2("c: %d %d", c.0, c.1));
			System.puts(Strings.format2(" %d %d\n", c.2, c.3));
			System.puts(Strings.format1("All a Zero? %z\n", all_a_zero));
			System.puts(Strings.format1("All b Zero? %z\n", all_b_zero));
		}

		var t = computeShortest(a, b, c, digit, all_a_zero, all_b_zero, acceptBounds);
		if (DEBUG) {
			System.puts(Strings.format2("d_0: %d, e_0: %d \n", t.0, t.1 + e_10));
		}

		return renderFloatingDecimal(t.0, t.1 + e_10, arr, pos);
	}

	private def multAndShift(val: u32, factor: (u32, u32, u32, u32), q: int) -> (u32, u32, u32, u32) {
		var factor_low = (0u, 0u, factor.2, factor.3);
		var factor_high = (0u, 0u, factor.0, factor.1);
	
		// factor_low + factor_high << 64
		var p_low = u128Mult((0u, 0u, 0u, val), factor_low);
		var p_high = u128Mult((0u, 0u, 0u, val), factor_high);
		
		var p_low_shifted = u128Shift(p_low, -q);
		var p_high_shifted: (u32, u32, u32, u32);

		// remainder here is the values discarded by the shift operations
		// the summed discarded values can create a carry 
		var p_low_remainder = u128Shift(u128Shift(p_low, 128 - q), -(128 - q));
		var p_high_remainder: (u32, u32, u32, u32);
	
		if (q < 64) {
			p_high_shifted = u128Shift(p_high, 64 - q);
			p_high_remainder = (0u, 0u, 0u, 0u);
		} else {
			var n_shift: int = q - 64;
			p_high_shifted = u128Shift(p_high, -n_shift);
			p_high_remainder = u128Shift(u128Shift(p_high, 128 - n_shift), -(128 - n_shift));
		}
	
		var result = u128Add(p_low_shifted, p_high_shifted);
		var carry = u128Shift(u128Add(u128Shift(p_high_remainder, 64), p_low_remainder), -q);
		return u128Add(result, carry);
	}

	private def pow5bits(e: u32) -> int {
		return  int.!(((e * 1217359) >> 19) + 1);
	}

	// O(n) naive operation
	def pow5(n: u32) -> (u32, u32, u32, u32) {
		if (n == 0) return (0u, 0u, 0u, 1u);
		var result: (u32, u32, u32, u32) = (0u, 0u, 0u, 1u);
		for (i = 0; i < n; i++) {
			result = u128Mult(result, (0u, 0u, 0u, 5u));
		}
		return result;
	}


	// if we did the clever trick for the case e >= 0, (a, b, c) can all become u32.
	def computeShortest(
		a: (u32, u32, u32, u32),
		b: (u32, u32, u32, u32),
		c: (u32, u32, u32, u32),
		digit: u32,
		all_a_zero: bool,
		all_b_zero: bool,
		acceptBounds: bool) -> (u32, int) {

		var i: int = 0;
		if (!acceptBounds)
			c = u128Subtract(c, (0u, 0u, 0u, 1u));
		
		while (u128Compare(u128Div10(a), u128Div10(c)) < 0) {
			all_a_zero = all_a_zero && (u128Mod10(a) == 0);
			a = u128Div10(a);
			c = u128Div10(c);

			all_b_zero = all_b_zero && digit == 0;
			digit = u128Mod10(b);
			b = u128Div10(b);

			i += 1;
		}
		if (acceptBounds && all_a_zero) {
			while (u128Mod10(a) == 0) {
				a = u128Div10(a);
				c = u128Div10(c);

				all_b_zero = all_b_zero && digit == 0;
				digit = u128Mod10(b);
				b = u128Div10(b);
				i += 1;
			}
		}

		if (DEBUG)
		{
			System.puts(Strings.format1("Compute shortest: final a %d\n", a.3));
			System.puts(Strings.format1("Compute shortest: final b %d\n", b.3));
			System.puts(Strings.format1("Compute shortest: final c %d\n", c.3));
			System.puts(Strings.format1("Compute shortest: digit: %d\n", digit));
		}

		var break_tie_down = (b.3 % 2 == 0);
		var is_tie: bool = (digit == 5 && all_b_zero);
		var want_round_down: bool = (digit < 5) || (is_tie && break_tie_down);
		var round_down: bool = (want_round_down && (u128Compare(a, b) != 0 || all_a_zero))
			|| (u128Compare(u128Add(b, (0u, 0u, 0u, 1u)), c) > 0);

		if (DEBUG)
		{
			System.puts(Strings.format1("Compute shortest: is_tie: %z\n", is_tie));
			System.puts(Strings.format1("Compute shortest: all_a_zero: %z\n", all_a_zero));
			System.puts(Strings.format1("Compute shortest: all_b_zero: %z\n", all_b_zero));
			System.puts(Strings.format1("Compute shortest: want_round_down: %z\n", want_round_down));
			System.puts(Strings.format1("Compute shortest: round_down: %z\n", round_down));
		}

		// the resulting b is guaranteed to be within u32 range
		if (round_down)
			return (b.3, i);
		return (b.3 + 1, i);
	}

	def renderFloatingDecimal(d: u32, e: int, a: Array<byte>, pos: int) -> int {
		var startingPos: int = pos;
		var length: int = 0;

		var useFixedNotation: bool = useFixedNotation(d, e);
		if (DEBUG)
			System.puts(Strings.format1("Use fixed notation %z \n", useFixedNotation));
		if (useFixedNotation) {
			length = renderFixed(d, e, a, pos, true);
		} else {
			length = renderScientific(d, e, a, pos);
		}

		if (DEBUG)
		{
			System.puts("Rendered: ");
			for (i = startingPos; i < startingPos + length; i++)
			{
				System.puts(Strings.format1("%c", a[i]));
			}
			System.puts("\n");
		}

		return length;
	}

	private def renderFixed(d: u32, e: int, a: Array<byte>, pos: int, renderTrailingZero: bool) -> int {
		var length: int = 0;
		var isZeroPointX: bool = false;
		var digitWidth: int = getDigitWidth(d);
		var digitsRight: int = Ints.min(Ints.max(0, -e), digitWidth);
		if (e >= 0) {
			length = digitWidth + e;
			if (renderTrailingZero)
				length += 2;  // extra 2 for trailing zero
		} else {
			length = digitWidth + 1; // add the decimal point
			if (digitWidth + e <= 0) {
				isZeroPointX = true;
				length += 1 + -(digitWidth + e);
			}
		}

		if (DEBUG)
		{
			System.puts(Strings.format1("Fixed: Digit width is %d \n", digitWidth));
			System.puts(Strings.format1("Fixed: Sig Digits right of decimal point is %d\n", digitsRight));
			System.puts(Strings.format1("Fixed: Unsigned float length is %d \n", length));
		}

		pos += length - 1; // start from to right, move to left

		// render trailing zero for fixed notation
		if (e >= 0 && renderTrailingZero) {
			a[pos--] = '0';
			a[pos--] = '.';
		}

		// render trailing zeros right after decimal point
		for (i = 0; i < e; i++)
			a[pos--] = '0';
		
		// render digits right of decimal point
		var n: u32 = d;
		for (i = 0; i < digitsRight; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		// render leading zeros right of decimal point
		for (i = digitWidth + e; i < 0; i++)
			a[pos--] = '0';
		
		// render "0."" or "."
		if (isZeroPointX) {
			a[pos--] = '.';
			a[pos--] = '0';
		} else if (e < 0) {
			a[pos--] = '.';
		}

		// render digits left of decimal point
		for (i = 0; i < digitWidth - digitsRight; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		return length;
	}

	private def renderScientific(d: u32, e: int, a: Array<byte>, pos: int) -> int {
		var digitWidth: int = getDigitWidth(d);
		var fixedLength: int  = renderFixed(d, -(digitWidth - 1), a, pos, false);
		pos += fixedLength;

		var normalizedE = e + (digitWidth - 1);
		var normalizedEWidth = getDigitWidth(Ints.abs(normalizedE));
		var scientificLength: int = 1 + normalizedEWidth;
		if (normalizedE < 0)
			scientificLength += 1;
		
		pos += scientificLength - 1;

		var n: u32 = u32.!(Ints.abs(normalizedE));
		
		for (i = 0; i < normalizedEWidth; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		if (normalizedE < 0)
			a[pos--] = '-';
		
		a[pos--] = 'E';
		
		return fixedLength + scientificLength;
	}

	private def useFixedNotation(d: u32, e: int) -> bool {
		if (d == 0)
			return true;
		if (e > 10)
			return false;
		if (e > 0) {
			for (i = 0; i < e; i++)
			{
				d = d * 10;
				// check inside for to prevent overflow of u32
				if (d >= 10000000)
					return false;
			}
			return true;
		}
		if (e == 0)
			return d < 10000000;
		var digitWidth: int = getDigitWidth(d);
		return digitWidth + e >= -2;
	}

	private def getDigitWidth(d: u32) -> int {
		var digitWidth: int = 0;
		if (d == 0) return 1;
		var n = d;
		while (n != 0) {
			n = n / 10;
			digitWidth += 1;
		}
		return digitWidth;
	}

	private def getLastPosDecimalDigit(d: u32) -> (u32, int) {
		return (d / 10, int.view(d % 10));
	}
	
	private def log10Pow5(e: u32) -> int {
		return int.!((e * 732923u) >> 20);
	}

	private def multipleOfPowerOf2(value: u32, p: u32) -> bool {
		return (value & ((1u << byte.!(p)) - 1)) == 0;
	}

	private def u128Add(a: (u32, u32, u32, u32), b: (u32, u32, u32, u32)) -> (u32, u32, u32, u32) {
		var carry: u64 = 0;
		
		var sum3: u64 = u64.view(a.3) + u64.view(b.3) + carry;
		var res3 = u32.view(sum3);
		carry = sum3 >> 32;
		
		var sum2: u64 = u64.view(a.2) + u64.view(b.2) + carry;
		var res2 = u32.view(sum2);
		carry = sum2 >> 32;
		
		var sum1: u64 = u64.view(a.1) + u64.view(b.1) + carry;
		var res1 = u32.view(sum1);
		carry = sum1 >> 32;
		
		var sum0: u64 = u64.view(a.0) + u64.view(b.0) + carry;
		var res0 = u32.view(sum0);
		
		return (res0, res1, res2, res3);
	}

	private def u128Subtract(a: (u32, u32, u32, u32), b: (u32, u32, u32, u32)) -> (u32, u32, u32, u32) {
		var borrow: u64 = 0;
		
		var diff3: i64 = i64.view(a.3) - i64.view(b.3) - i64.view(borrow);
		var res3 = u32.view(diff3);
		if (diff3 < 0) {
			borrow = 1;
		} else {
			borrow = 0;
		}
		
		var diff2: i64 = i64.view(a.2) - i64.view(b.2) - i64.view(borrow);
		var res2 = u32.view(diff2);
		if (diff2 < 0) {
			borrow = 1;
		} else {
			borrow = 0;
		}
		
		var diff1: i64 = i64.view(a.1) - i64.view(b.1) - i64.view(borrow);
		var res1 = u32.view(diff1);
		if (diff1 < 0) {
			borrow = 1;
		} else {
			borrow = 0;
		}
		
		var diff0: i64 = i64.view(a.0) - i64.view(b.0) - i64.view(borrow);
		var res0 = u32.view(diff0);
		
		return (res0, res1, res2, res3);
	}

	private def u128Mult(a: (u32, u32, u32, u32), b: (u32, u32, u32, u32)) -> (u32, u32, u32, u32) {
		var r0: u64 = 0;
		var r1: u64 = 0;
		var r2: u64 = 0;
		var r3: u64 = 0;
		
		r3 += u64.view(a.3) * u64.view(b.3);
		
		r2 += u64.view(a.2) * u64.view(b.3);
		r2 += u64.view(a.3) * u64.view(b.2);
		
		r1 += u64.view(a.1) * u64.view(b.3);
		r1 += u64.view(a.2) * u64.view(b.2);
		r1 += u64.view(a.3) * u64.view(b.1);
		
		r0 += u64.view(a.0) * u64.view(b.3);
		r0 += u64.view(a.1) * u64.view(b.2);
		r0 += u64.view(a.2) * u64.view(b.1);
		r0 += u64.view(a.3) * u64.view(b.0);
		
		r2 += r3 >> 32;
		r3 = r3 & 0xFFFFFFFFu;
		
		r1 += r2 >> 32;
		r2 = r2 & 0xFFFFFFFFu;
		
		r0 += r1 >> 32;
		r1 = r1 & 0xFFFFFFFFu;
		
		r0 = r0 & 0xFFFFFFFFu;
		
		return (u32.view(r0), u32.view(r1), u32.view(r2), u32.view(r3));
	}

	private def u128Compare(a: (u32, u32, u32, u32), b: (u32, u32, u32, u32)) -> i64 {
		if (a.0 != b.0) {
			return i64.view(a.0) - i64.view(b.0);
		}
		if (a.1 != b.1) {
			return i64.view(a.1) - i64.view(b.1);
		}
		if (a.2 != b.2) {
			return i64.view(a.2) - i64.view(b.2);
		}
		return i64.view(a.3) - i64.view(b.3);
	}

	private def u128Shift(val: (u32, u32, u32, u32), shift: int) -> (u32, u32, u32, u32) {
		if (shift == 0) {
			return val;
		}
		
		if (shift > 0) { // Left shift
			if (shift >= 128) {
				return (0u, 0u, 0u, 0u);
			}
			
			var word_shift = shift / 32;
			var bit_shift = shift % 32;
			
			var result: (u32, u32, u32, u32);
			
			if (word_shift == 0) {
				result = val;
			} else if (word_shift == 1) {
				result = (val.1, val.2, val.3, 0u);
			} else if (word_shift == 2) {
				result = (val.2, val.3, 0u, 0u);
			} else if (word_shift == 3) {
				result = (val.3, 0u, 0u, 0u);
			} else {
				return (0u, 0u, 0u, 0u);
			}
			
			if (bit_shift > 0) {
				var carry: u32 = 0;
				var new_carry: u32;
				
				new_carry = result.3 >> byte.!(32 - bit_shift);
				var r3 = (result.3 << byte.!(bit_shift)) | carry;
				carry = new_carry;
				
				new_carry = result.2 >> byte.!(32 - bit_shift);
				var r2 = (result.2 << byte.!(bit_shift)) | carry;
				carry = new_carry;
				
				new_carry = result.1 >> byte.!(32 - bit_shift);
				var r1 = (result.1 << byte.!(bit_shift)) | carry;
				carry = new_carry;
				
				var r0 = (result.0 << byte.!(bit_shift)) | carry;
				
				result = (r0, r1, r2, r3);
			}
			
			return result;
		} else { // Right shift
			var s = -shift;
			if (s >= 128) {
				return (0u, 0u, 0u, 0u);
			}
			
			var word_shift = s / 32;
			var bit_shift = s % 32;
			
			var result: (u32, u32, u32, u32);
			
			if (word_shift == 0) {
				result = val;
			} else if (word_shift == 1) {
				result = (0u, val.0, val.1, val.2);
			} else if (word_shift == 2) {
				result = (0u, 0u, val.0, val.1);
			} else if (word_shift == 3) {
				result = (0u, 0u, 0u, val.0);
			} else {
				return (0u, 0u, 0u, 0u);
			}
			
			if (bit_shift > 0) {
				var r3 = (result.3 >> byte.!(bit_shift)) | (result.2 << byte.!(32 - bit_shift));
				var r2 = (result.2 >> byte.!(bit_shift)) | (result.1 << byte.!(32 - bit_shift));
				var r1 = (result.1 >> byte.!(bit_shift)) | (result.0 << byte.!(32 - bit_shift));
				var r0 = result.0 >> byte.!(bit_shift);
				
				result = (r0, r1, r2, r3);
			}
			
			return result;
		}
	}

	private def u128Mod10(a: (u32, u32, u32, u32)) -> u32 {
		var remainder: u64 = 0;
		var temp: u64;
		
		temp = (remainder << 32) + u64.view(a.0);
		remainder = temp % 10;
		
		temp = (remainder << 32) + u64.view(a.1);
		remainder = temp % 10;
		
		temp = (remainder << 32) + u64.view(a.2);
		remainder = temp % 10;
		
		temp = (remainder << 32) + u64.view(a.3);
		remainder = temp % 10;
		
		return u32.view(remainder);
	}

	private def u128Div10(a: (u32, u32, u32, u32)) -> (u32, u32, u32, u32) {
		var remainder: u64 = 0;
		var temp: u64;
		
		temp = (remainder << 32) | u64.view(a.0);
		var r0 = u32.view(temp / 10);
		remainder = temp % 10;
		
		temp = (remainder << 32) | u64.view(a.1);
		var r1 = u32.view(temp / 10);
		remainder = temp % 10;
		
		temp = (remainder << 32) | u64.view(a.2);
		var r2 = u32.view(temp / 10);
		remainder = temp % 10;
		
		temp = (remainder << 32) | u64.view(a.3);
		var r3 = u32.view(temp / 10);
		
		return (r0, r1, r2, r3);
	}
}
