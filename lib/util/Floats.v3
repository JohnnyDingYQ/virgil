// Credit to the ryu algorithm: https://dl.acm.org/doi/pdf/10.1145/3192366.3192369

component Floats {
	private def FLOAT_EXP_WIDTH: byte = 8;
	private def FLOAT_SIGN_WIDTH: byte = 1;
	private def FLOAT_MANTISSA_BITS: byte = 23;
	private def FLOAT_BIAS: byte = 127;

	private def DEBUG: bool = true;

    def renderFloat(val: float, a: Array<byte>, pos: int) -> int {
		var length: int = 0;
        if (u32.view(val) >> byte.!(FLOAT_MANTISSA_BITS + FLOAT_EXP_WIDTH) == 1u) {
			a[pos++] = '-';
			return 1 + renderPosFloat(val, a, pos);
		}
		return renderPosFloat(val, a, pos);
    }
	

	def renderPosFloat(val: float, a: Array<byte>, pos: int) -> int {
		var bits = u32.view(val);
		var exponent: u32 = (bits >> FLOAT_MANTISSA_BITS) & ((1u << FLOAT_EXP_WIDTH) - 1);
		var mantissa: u32 = bits & ((1u << FLOAT_MANTISSA_BITS) - 1);

		if (DEBUG)
			System.puts(Strings.format2("Exponent: %d | Mantissa: %d \n", exponent, mantissa));

		if (exponent == u32.view(0b11111111) || (exponent == 0 && mantissa == 0)) {
			return renderFloatSpecial(exponent, mantissa, a, pos);
		}

		return renderPosFloatNaive(exponent, mantissa, a, pos);
	}


	def renderFloatSpecial(exponent: u32, mantissa: u32, a: Array<byte>, pos: int) -> int {
		if (mantissa != 0) {
			a[pos++] = 'N';
			a[pos++] = 'a';
			a[pos] = 'N';
			return 3;
		}
		if (exponent != 0) {
			a[pos++] = 'I';
			a[pos++] = 'n';
			a[pos++] = 'f';
			a[pos++] = 'i';
			a[pos++] = 'n';
			a[pos++] = 'i';
			a[pos++] = 't';
			a[pos] = 'y';
			return 8;
		}
		a[pos] = '0';
		return 1;
	}

	def renderPosFloatNaive(exponent: u32, mantissa: u32, arr: Array<byte>, pos: int) -> int {
		// Step 1: Decode
		var e_f: int;
		var m_f: u32;

		if (exponent == 0) {
			m_f = mantissa;
			e_f = int.!(1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS);
		}
		else {
			m_f = (1u << FLOAT_MANTISSA_BITS) + mantissa;
			e_f = int.!(exponent) - FLOAT_BIAS - FLOAT_MANTISSA_BITS;
		}

		if (DEBUG)
			System.puts(Strings.format2("m_f & e_f: %d * 2^%d \n", m_f, e_f));

		var e_2: int = e_f - 2;

		// Step 2: Determine interval of information preserving outputs
		var v: u32 = 4u * m_f;
		var w: u32 = 4u * m_f + 2u;
		var u: u32 = 4u * m_f;
		if (mantissa == 0 && exponent > 1)
			u -= 1u;
		else
			u -= 2u;
		
		// Step 3: Convert (u,v,w) * 2^(e_2) to a decimal power base.

		var e_10: int;
        var a: u64;
        var b: u64;
        var c: u64;

        if (e_2 >= 0) {
            e_10 = 0;
            var exp: u64 = u64.!(1) << byte.!(e_2);
            a = u64.!(u) * exp;
            b = u64.!(v) * exp;
            c = u64.!(w) * exp;
        }
        else {
            e_10 = e_2;
            var exp: u64 = pow5(u32.!(-e_2));
            a = u64.!(u) * exp;
            b = u64.!(v) * exp;
            c = u64.!(w) * exp;
        }

        System.puts(Strings.format2("v: %d, e_2: %d \n", v, e_2));
        System.puts(Strings.format2("b: %d, e_10: %d \n", b, e_10));

		var acceptLarger: bool = mantissa % 2 == 0;
		var acceptSmaller: bool = acceptLarger;

		var t = computeShortest(a, b, c, acceptSmaller, acceptLarger);
		System.puts(Strings.format2("d_0: %d, e_0: %d \n", t.0, t.1));

		return renderFloatingDecimal(t.0, t.1 + e_10, arr, pos);
	}

	// O(n) naive operation
	def pow5(n: u32) -> u64 {
		var result: u64 = 1;
		for (i = 0; i < n; i++)
			result = (result << 2) + result;
		return result;
	}

	def computeShortest(a: u64, b: u64, c: u64, acceptSmaller: bool, acceptLarger: bool) -> (u64, int) {
		var i: int = 0;
		if (!acceptLarger)
			c -= 1;
		var all_a_zero: bool = true;
		var all_b_zero: bool = true;
		var digit: u64 = 0;

		
		while (a / 10 < c / 10) {
			all_a_zero = all_a_zero && (a % 10 == 0);
			a = a / 10;
			c = c / 10;

			digit = b % 10;
			all_b_zero = all_b_zero && digit == 0;
			b = b / 10;

			i += 1;
		}
		if (acceptSmaller && all_a_zero) {
			while (a % 10 == 0) {
				a = a / 10;
				c = c / 10;
				i += 1;

				digit = b % 10;
				all_b_zero = all_b_zero && digit == 0;
				b = b / 10;
			}
		}

		var break_tie_down = (b % 2 == 0);
		var is_tie: bool = (digit == 5) && all_b_zero;
		var want_round_down: bool = (digit < 5) || (is_tie && break_tie_down);
		var round_down: bool = (want_round_down && (a != b || all_a_zero)) || (b + 1 > c);

		if (round_down)
			return (b, i);
		return (b + 1, i);
	}

	def renderFloatingDecimal(d: u64, e: int, a: Array<byte>, pos: int) -> int {
		var digitWidth: int = 1;
		var t = getLastPosDecimalDigit(d);
		while (t.0 != 0) {
			t = getLastPosDecimalDigit(t.0);
			digitWidth += 1;
		}
		var length: int = 0;
		var isZeroPointX: bool = false;
		if (e >= 0) {
			length = digitWidth + e;
		} else {
			length = digitWidth + 1; // add the decimal point
			if (digitWidth + e < 0) {
				isZeroPointX = true;
				length += 1 + -(digitWidth + e);
			}
		}

		pos += length - 1; // start from to right, move to left

		// render trailing zeros
		for (i = 0; i < e; i++)
			a[pos--] = '0';
		
		var n: u64 = d;
		for (i = 0; i < digitWidth; i++) {
			var t = getLastPosDecimalDigit(n);
			a[pos--] = byte.!(t.1 + '0');
			n = t.0;
		}

		// render leading zeros after decimal point
		for (i = digitWidth + e; i < 0; i++)
			a[pos--] = '0';
		
		// render 0.
		if (isZeroPointX) {
			a[pos--] = '.';
			a[pos--] = '0';
		}

		return length;
	}

	def getLastPosDecimalDigit(d: u64) -> (u64, int) {
		return (d / 10, int.view(d) % 10);
	}
}

